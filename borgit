#! /usr/bin/env python3
import re


# This pattern won't perfectly match IPv4/IPv6/fqdn, but should provide enough
# utility for error output without extra complexity.
REMOTE_BORG_PATTERN = re.compile(
    '^ssh://(?P<username>[a-z]+)_backups'
    '@(?P<fqdn_or_ip>[a-zA-Z0-9.-[\]:]+)/~/repository$'
)
CONF_STRUCTURE = {
    # TODO: Convert to {check_method: <method>, type: list|single, description: <description>, optional: <bool>}
    'repo_passphrase': {
        'validate': validate_repo_passphrase,
        'type': 'single',
        'description': 'Passphrase for repository.',
        'optional': False,
    },
    'local_destination_paths': {
        'validate': validate_local_file_path,
        'type': 'single',
        'description': 'Local backup repository destination.',
        'optional': False,
    },
    'remote_path': {
        'validate': validate_remote_borg_address,
        'type': 'single',
        'description': 'Remote backup repository destination.',
        'optional': False,
    },
    'backup_source_paths': {
        'validate': validate_local_file_path,
        'type': 'list',
        'description': 'Local directories to back up.',
        'optional': True,
    },
    'check_files': {
        'contents': {
            'path': {
                'validate': validate_local_file_path,  # TODO: Check this is right
                'type': 'list',
                'description': 'Path to check in backup.',
                'optional': False,
            },
            'check_command': {
                'validate': validate_local_executable,
                'type': 'single',
                'description': (
                    'Script to run to check. Any output will be added to '
                    'backup notifications, as INFO if the check is '
                    'successful, WARNING if it exits with a code of 1 '
                    'or ERROR if it exits witha code of 2'
                ),
                'optional': False,
            },
            'check_arguments': {
                'validate': None,  # These could be anything, we will str them
                'type': 'list',
                'description': (
                    'Arguments to run check script with.',
                ),
                'optional': True,
            },
            'minimum_size': {
                'validate': validate_size_input,
                'type': 'single',
                'description': (
                    'Notify if the specified files are below this size. '
                    'e.g. 4M would notify if the file was smaller than 4MB.'
                ),
                'optional': True,
            },
        },
        'type': 'list_of_dicts',
        'description': (
            'Files to check and check approaches to use. '
            'These checks will be run after every backup is taken. '
            'You may need a lot of space as files to be checked will be '
            'extracted from the backup, checked, then removed (so large '
            'files may cause temporary high disk and network usage).'
        ),
        'optional': True,
    },
    'check_file_extraction_location': {
        'validate': validate_local_file_path,
        'type': 'single',
        'description': (
            'Where to store extracted backups during checking. '
            'Default is to use python secure tempdir creation.'
        ),
        'optional': True,
    },
    'notification_email': {
        'validate': validate_email_address,
        'type': 'list',
        'description': (
            'Email addresses to send notifications to. '
            'Make sure these are going to addresses you have permission '
            'to send to, or enjoy working your way around spam filtering for '
            'years to come.'
        ),
        'optional': True,
    },
    'syslog_tag': {
        'validate': None,  # This could be anything, we will str it
        'type': 'single',
        'description': (
            'Syslog tag. If set, logs will be sent to syslog.'
        ),
        'optional': True,
    },
}


def load_config(path):
    with open(path) as conf_handle:
        config = json.load(conf_handle)

    for conf_entry in CONF_STRUCTURE:
       # TODO: Also needs to be recursive

    
def validate_local_file_path(config_entry):
    if not os.path.exists(config_entry):
        raise ValidationError(
            'Could not find local path: {path}'.format(path=config_entry),
        )


def validate_repo_passphrase(config_entry):
    if not isinstance(config_entry, basestring):
        raise ValidationError(
            'Expected repo passphrase to be a string.',
        )


def validate_remote_borg_address(config_entry):
    if not REMOTE_BORG_PATTERN.findall(config_entry):
        raise ValidationError(
            'Expected remote borg backup location in the form: '
            'ssh://<username>_backups@<FQDN_OR_IP>/~/repository',
        )


def perform_backup(# TODO):
    # 0. Validate local and remote repositories, abort if one corrupt, but not if file check failed)
    # 1. Do backup to local location
    # 2. Validate local backup (abort if repository corrupt, but not if file check failed)
    # 3. Do backup to remote location
    # 4. Validate remote backup
    # 5. (finally) Send report mail
