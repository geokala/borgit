#! /usr/bin/env python3
"""Script for automation of borg backups, including testing the backups.
This wants to keep one local and remote copy.
It also wants to inform someone of any errors encountered."""
import os
import re


# This pattern won't perfectly match IPv4/IPv6/fqdn, but should provide enough
# utility for error output without extra complexity.
REMOTE_BORG_REGEX = re.compile(
    r'^ssh://(?P<username>[a-z]+)_backups'
    r'@(?P<fqdn_or_ip>[a-zA-Z0-9.-[\]:]+)/~/repository$'
)
SIZE_REGEX = re.compile(
    r'^(?P<value>[0-9]+)(?P<unit>[A-Za-z]+)$'
)
CONF_STRUCTURE = {
    'repo_passphrase': {
        'validate': validate_string,
        'type': 'single',
        'description': 'Passphrase for repository.',
        'optional': False,
    },
    'local_destination_paths': {
        'validate': validate_local_file_path,
        'type': 'single',
        'description': 'Local backup repository destination.',
        'optional': False,
    },
    'remote_path': {
        'validate': validate_remote_borg_address,
        'type': 'single',
        'description': 'Remote backup repository destination.',
        'optional': False,
    },
    'backup_source_paths': {
        'validate': validate_local_file_path,
        'type': 'list',
        'description': 'Local directories to back up.',
        'optional': True,
    },
    'check_files': {
        'contents': {
            'path': {
                'validate': validate_local_file_path,
                'type': 'list',
                'description': 'Path to check in backup.',
                'optional': False,
            },
            'check_command': {
                'validate': validate_local_executable,
                'type': 'single',
                'description': (
                    'Script to run to check. Any output will be added to '
                    'backup notifications, as INFO if the check is '
                    'successful, WARNING if it exits with a code of 1 '
                    'or ERROR if it exits witha code of 2'
                ),
                'optional': False,
            },
            'check_arguments': {
                'validate': None,  # These could be anything, we will str them
                'type': 'list',
                'description': (
                    'Arguments to run check script with.',
                ),
                'optional': True,
            },
            'minimum_size': {
                'validate': validate_size_input,
                'type': 'single',
                'description': (
                    'Notify if the specified files are below this size. '
                    'e.g. 4M would notify if the file was smaller than 4MB.'
                ),
                'optional': True,
            },
        },
        'type': 'list_of_dicts',
        'description': (
            'Files to check and check approaches to use. '
            'These checks will be run after every backup is taken. '
            'You may need a lot of space as files to be checked will be '
            'extracted from the backup, checked, then removed (so large '
            'files may cause temporary high disk and network usage).'
        ),
        'optional': True,
    },
    'check_file_extraction_location': {
        'validate': validate_local_file_path,
        'type': 'single',
        'description': (
            'Where to store extracted backups during checking. '
            'Default is to use python secure tempdir creation.'
        ),
        'optional': True,
    },
    'notification_email': {
        'validate': validate_email_address,
        'type': 'list',
        'description': (
            'Email addresses to send notifications to. '
            'Make sure these are going to addresses you have permission '
            'to send to, or enjoy working your way around spam filtering for '
            'years to come.'
        ),
        'optional': True,
    },
    'syslog_tag': {
        'validate': None,  # This could be anything, we will str it
        'type': 'single',
        'description': (
            'Syslog tag. If set, logs will be sent to syslog.'
        ),
        'optional': True,
    },
}


class InvalidConfiguration(Exception):
    """Raised when configuration issues are encountered in validation."""


def validate_config(config, prefix=None):
    """Validate the provided config, based on the defined CONF_STRUCTURE."""
    prefix = prefix or []

    configuration_issues = []
    for conf_entry, schema in CONF_STRUCTURE.items():
        key_name = '.'.join(prefix + [conf_entry])
        if conf_entry not in config:
            if not schema['optional']:
                configuration_issues.append(
                    '{key} was not found in configuration, but is required.'
                    .format(key=key_name)
                )
            # No need to validate an empty configuration entry.
            continue

        if schema['type'] == 'list_of_dicts':
            configuration_issues.extend(
                validate_config(
                    config=config[conf_entry],
                    prefix=prefix.append(conf_entry)
                )
            )

        validation = schema.get('validation')
        if validation:
            if schema['type'] == 'single':
                entry = [config[conf_entry]]
            elif schema['type'] == 'list':
                entry = config[conf_entry]
                if not isinstance(entry, list):
                    configuration_issues.append(
                        '{key} is expected to be a list but was not.'
                        .format(key=key_name)
                    )
            else:
                raise RuntimeError(
                    'Unknown type in schema: {schema_type}'.format(
                        schema_type=schema['type'],
                    )
                )
            entry_issue = validation(entry)
            if entry_issue:
                entry_issue = (
                    '{key} is invalid: {issue}'.format(
                        key=key_name,
                        issue=entry_issue,
                    )
                )
                configuration_issues.append(entry_issue)

    if prefix:
        return configuration_issues

    # We are at the top level, raise any configuration issues
    if configuration_issues:
        raise InvalidConfiguration('\n'.join(configuration_issues))
    return []


def validate_local_file_path(config_value):
    """Validate whether the supplied value is a local file path."""
    if not os.path.exists(config_value):
        return (
            'Could not find local path: {path}'.format(path=config_value),
        )
    return ''


def validate_string(config_value):
    """Validate that the provided value is a string."""
    if not isinstance(config_value, str):
        return (
            'Expected a string.',
        )
    return ''


def validate_remote_borg_address(config_value):
    """Validate that the value is a supported remote borg address."""
    if not REMOTE_BORG_REGEX.findall(config_value):
        return (
            'Expected remote borg backup location in the form: '
            'ssh://<username>_backups@<FQDN_OR_IP>/~/repository',
        )
    return ''


def validate_local_executable(config_value):
    """Validate that a local executable file has been provided."""
    if not os.path.isfile(config_value):
        return '{path} does not exist.'.format(path=config_value)
    if not os.access(config_value, os.X_OK):
        return '{path} is not executable.'.format(path=config_value)
    return ''


def validate_size_input(config_value):
    """Validate that a parseable size has been provided."""
    try:
        convert_size_input(config_value)
        return ''
    except SizeConversionError as err:
        return str(err)


def validate_email_address(config_value):
    """Very naive e-mail address validation.
    This is only intended to try to avoid the silliest of errors in e-mail
    address configuration."""
    string_check_failure = validate_string(config_value)
    if string_check_failure:
        return string_check_failure
    if config_value.count('@') != 1:
        return 'Expected an e-mail address with only one @.'
    # We'll do more checking if problems manifest, but just including e-mail
    # testing in the commands should be a reasonable alternative.
    return ''


class SizeConversionError(Exception):
    """Raised when failing an attempt to convert a size input."""


def convert_size_input(size_input):
    """Convert a size input to the appropriate size in bytes."""
    # Supported size specifiers, with the required multiplier
    supported_size_specifiers = {
        'b': 1,
        'mib': 1024,
        'mb': 1000,
        'm': 1000,
    }
    output_specifiers = ', '.join(('B', 'MiB', 'MB', 'M'))

    first_parse = SIZE_REGEX.match(size_input)
    if not first_parse:
        raise SizeConversionError(
            'Could not convert {inp} to size. Expected numbers followed by '
            'a unit ({units}). e.g. 14MiB'.format(
                inp=size_input,
                units=output_specifiers,
            )
        )

    first_parse = first_parse.groupdict()
    multiplier = supported_size_specifiers.get(first_parse['unit'].lower())
    if not multiplier:
        raise SizeConversionError(
            'Could not convert {inp} to size. Unrecognised unit {unit}. '
            'Valid units are: {units}'.format(
                inp=size_input,
                unit=first_parse['unit'],
                units=output_specifiers,
            )
        )

    return int(first_parse['value']) * multiplier


# run_backup command:
# 0. Validate local and remote repositories, abort if one corrupt, but not if
# file check failed)
# 1. Do backup to local location
# 2. Validate local backup (abort if repository corrupt, but not if file check
# failed)
# 3. Do backup to remote location
# 4. Validate remote backup
# 5. (finally) Send report mail
#
# Also needed:
#  - e-mail_test command
#  - config_validate command
#  - validate_backup command
#
# For extracting files for testing, we have to remove the leading /, but
# otherwise it's just a local file path
